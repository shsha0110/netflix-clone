# netflix-clone
## 3주차 - 응하는 넷플릭스
1. 프로젝트 구조 설계 및 초기 설정
* ESM (ES Modules) 환경 구성:
    * index.html에 <script type="module" src="app.js"></script>를 추가하여 app.js를 진입점(Entry Point)으로 설정.
    * 기능별로 JS 파일을 분리.
    * CSS 모듈화 계획: 공통 스타일과 컴포넌트별 스타일 파일을 분리하여 관리.


2. 헤더 모달 기능 구현
* HTML 구조 생성:
    * 헤더 영역에 '알림'과 '프로필' 요소 아래에 숨겨진 모달 생성
* CSS로 초기 상태 스타일링:
    * 모달이 보이지 않도록 초기 상태를 설정.
    * 호버했을 때 보일 위치를 설정.


3. 카드 슬라이더 모듈 구현
3.1. 기본 슬라이더 구조 (HTML/CSS)
* HTML 구조 생성:
    * 슬라이더 컨테이너
    * 카드들이 움직일 트랙
    * 카드
    * 좌/우 네비게이션 버튼
    * 페이지네이션
* CSS 스타일링:
    * 컨테이너 영역 밖의 카드 숨기기.
    * 트랙에 애니메이션 효과 미리 추가.
    * 슬라이더 컨테이너에 마우스를 올렸을 때 네비게이션 버튼이 보이도록 스타일링.
3.2. 슬라이더 기능 구현 (JavaScript)
* 기본 이동 기능:
    * 슬라이더 클래스 또는 함수를 생성.
    * 현재 트랙 위치를 기억할 변수(트랙 인덱스) 선언.
    * 네비게이션 버튼 클릭 시 트랙 인덱스를 변경하여 이동.
* 페이지네이션 연동:
    * 슬라이드가 이동할 때마다 트랙 인덱스에 맞춰 활성화된 페이지네이션에 active 클래스를 추가/제거.
* 카테고리별 개별 설정 적용:
    * 슬라이더를 생성할 때, 한 번에 이동할 카드 개수를 인자로 받도록 설계.
    * 이 인자를 바탕으로 가로 이동 거리와 트랙 인덱스 증가/감소량을 계산하도록 로직을 수정
3.3. 무한 캐러셀 구현 (Infinite Loop)
* 아이템 복제:
    * 슬라이더의 가장 왼쪽에 가장 마지막  트랙을, 가장 오른쪽에 첫 트랙을 복제.
* 초기 위치 설정:
    * 실제 시작 위치가 '복제된 마지막 트랙’이 아닌 '원본 첫 트랙’이 되도록 조정.
* 순환 로직 구현:
    * 마지막 트랙에서 다음 버튼을 눌러 '복제된 첫 트랙’으로 이동했을 때, 이벤트 감지.
    * 이벤트가 발생하면 '원본 첫 트랙’ 위치로 변경.
    * 반대 방향도 동일한 원리로 구현.

## 4주차 - 빌드와 데이터통신
1. Vite 개발 환경 구축 및 마이그레이션
* Vite 프로젝트 생성
* 기존 코드 이전

2. 동적 콘텐츠 렌더링 (단계별 구현)
2.1 (1차 목표): 정적 JSON 파일 연동 방식
* appData.json 파일 생성: public/data 폴더를 만들고, 그 안에 모든 컴포넌트의 데이터를 통합한 appData.json 파일 생성
* fetch로 데이터 로딩: main.js를 async 함수로 변경하고, fetch API를 활용해 데이터를 비동기적으로 로드
* 컴포넌트 리팩토링: 각 함수들이 하드코딩된 데이터를 사용하는 대신, fetch로 받아온 데이터를 인자로 받아 화면을 그리도록 수정
2.2 (2차 목표 / 심화): Mock Server 도입
* json-server 설치
* db.json 파일 생성: 프로젝트 최상위 폴더에 db.json 파일을 만들고, appData.json의 내용을 json-server 형식에 맞게 복사
* Mock Server 실행
* fetch URL 수정: fetch 요청을 포함하는 함수에서 경로를 mock server 주소로 변경하여 서버와 통신하는 코드로 전환

3.핵심 기능 구현
3.1. 좋아요 기능
* UI/UX 구현:
    * '좋아요' 버튼에 mouseover 이벤트 추가 시, 세부 의견(싫어요, 좋아요, 최고예요) 버튼들이 담긴 모달이 나타나도록 구현
    * '좋아요' 버튼에 click 이벤트 추가 시, 각 버튼의 기본 아이콘이 색칠된 아이콘으로 전환
* 상태 관리 로직:
    * 사용자의 의견 목록을 객체화(user_opinions)하고 별도 모듈에서 관리
    * 각 의견 버튼에 click 이벤트 추가. 클릭 시 user_opinions에 해당 콘텐츠와 의견 종류(‘싫어요’, ‘좋아요’, ‘최고예요’)를 추가하거나, 이미 같은 의견이 있다면 제거
* UI와 상태 연동:
    * 카드 UI가 렌더링될 때, user_opinions를 확인하여 저장된 의견이 있다면 해당 버튼 아이콘을 '선택된' 아이콘으로 표시
    * localStorage를 사용해 user_opinions를 저장하여, 페이지를 새로고침해도 사용자의 의견이 유지되도록 구현
3.2: 찜하기 기능
* UI/UX 구현:
    * ‘찜하기’ 버튼에 click 이벤트 추가 시, 각 버튼의 기본 아이콘(+)에서 선택된 아이콘(v)으로 전환
* 상태 관리 로직:
    * 찜한 콘텐츠 목록을 객체화(wishlist)하고 별도 모듈에서 관리
    * 각 찜하기 버튼에 click 이벤트 추가. 클릭 시 wishlist에 해당 콘텐츠를 추가하거나, 이미 같은 콘텐츠가 있다면 제거
* UI와 상태 연동:
    * 카드 UI가 렌더링될 때, wishlist를 확인하여 찜한 콘텐츠라면 버튼을 선택된 아이콘으로 표시
    * wishlist 배열에 변경이 생길 때마다, '내가 찜한 리스트' 카테고리 섹션을 다시 그리는 함수를 호출하여 화면에 즉시 반영
    * localStorage를 사용해 wishlist를 저장하여, 페이지를 새로고침해도 찜 목록이 유지되도록 구현